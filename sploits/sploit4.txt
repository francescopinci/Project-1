-----BUILDING SECURE COMPUTER SYSTEMS-----
---------PROJECT 1 - SPLOIT 4-------------

This sploit exploits the vulnerabilities of target4 at lines 29/30 to make the
str.getLen() call point to our shellcode.
First of all, the value of &str is for sure above the one of buf on stack, and
this should allow us to overwrite it with a standard buffer overflow.
Moreover, str.getLen() return value is totally under user control, and it
doesn't block us to go through the else branch and perform an unwrapped strcpy on buf. 
This could seem the perfect situation for a buffer overflow attack, but if the
standard technique is used, a SIGABRT is detected and the program stops. This
is due to the presence into the stack of a canary word that is pushed right after
the function prologue and whose value is compared to one copy of the original
value stored in a table. If the compared values are different, a buffer
overflow is detected and the program aborts. 
This can be seen in the last lines of the assembly code of print_sub_string
function for example, where the __stack_chk_fail routine is called if the
comparison is false.
So, in order to bypass this checking, we can exploit the next vulnerability,
the one generated by the call to str.getLen(). Being a virtual pointer, the
address of str is used to retrieve the offset of the method in the virtual table: register
$r3, where we will branch to, is loaded with &str + 12.
Since we can overwrite buf and we can branch to a different $r3 before the
canary comparison is performed, we can safely overwrite buf with the location where
str is stored, minus 12. Since we were pointing to the address of str, we'll
need to point to an address (-12) storing the address of the pointer to our
shellcode, that we can put basically everywhere in buf. We decided to put it
right after such pointer that would then store buf+4 and be located at buf. So our final arg1
looked like:

  __________________________________________________________________________
 |		      | 	  |	        |                     |     |
 | buf+4 = 0xbefffcf8 | shellcode | dummy chars | buf-12 = 0xbefffce8 | \0  |
 |____________________|___________|_____________|_____________________|_____|
 0                   3 4        40 41         87 88                 91 92 


